<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>포켓로그 스타일 턴제 RPG 프로토타입</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
<style>
  body { margin:0; padding:0; }
  #game-container { margin: auto; display: block; width: 800px; height: 600px; }
</style>
</head>
<body>
<div id="game-container"></div>

<script>
  const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    parent: 'game-container',
    physics: {
      default: 'arcade',
      arcade: {
        debug: false
      }
    },
    scene: {
      preload,
      create,
      update
    }
  };

  let player;
  let cursors;
  let enemy;
  let inBattle = false;
  let battleText;
  let turn = 'player'; // 'player' or 'enemy'
  let playerHP = 100;
  let enemyHP = 50;

  const game = new Phaser.Game(config);

  function preload() {
    // 간단한 사각형 플레이어와 적 생성 위해 이미지 만들기
    this.load.image('player', 'https://i.imgur.com/waPj8Ku.png'); // 픽셀 플레이어 이미지
    this.load.image('enemy', 'https://i.imgur.com/jf8k6Td.png');  // 픽셀 적 이미지
  }

  function create() {
    // 플레이어 위치와 스프라이트
    player = this.physics.add.sprite(100, 300, 'player');
    player.setCollideWorldBounds(true);

    // 적 위치 및 스프라이트 (맵에 나타나는 적)
    enemy = this.physics.add.sprite(600, 300, 'enemy');

    cursors = this.input.keyboard.createCursorKeys();

    // 충돌 감지 - 플레이어가 적에 닿으면 전투 시작
    this.physics.add.overlap(player, enemy, () => {
      if (!inBattle) startBattle(this);
    });

    // 전투 메시지 UI
    battleText = this.add.text(400, 50, '', { fontSize: '24px', fill: '#fff' }).setOrigin(0.5);
  }

  function update() {
    if (inBattle) return; // 전투 중에는 이동 불가

    player.setVelocity(0);

    if (cursors.left.isDown) {
      player.setVelocityX(-150);
    } else if (cursors.right.isDown) {
      player.setVelocityX(150);
    }
    if (cursors.up.isDown) {
      player.setVelocityY(-150);
    } else if (cursors.down.isDown) {
      player.setVelocityY(150);
    }
  }

  function startBattle(scene) {
    inBattle = true;
    battleText.setText('전투 시작! 당신의 턴입니다.');
    turn = 'player';

    // 전투 UI: 스킬 버튼 2개 생성
    createSkillButtons(scene);
  }

  function createSkillButtons(scene) {
    const skill1 = scene.add.text(200, 500, '공격', { fontSize: '20px', fill: '#0f0', backgroundColor: '#222' })
      .setInteractive()
      .on('pointerdown', () => playerAttack(scene, 10));

    const skill2 = scene.add.text(400, 500, '강한 공격', { fontSize: '20px', fill: '#f00', backgroundColor: '#222' })
      .setInteractive()
      .on('pointerdown', () => playerAttack(scene, 20));

    // 버튼 저장해서 나중에 삭제 가능하도록 처리
    scene.skillButtons = [skill1, skill2];
  }

  function playerAttack(scene, damage) {
    if (turn !== 'player') return;
    enemyHP -= damage;
    battleText.setText(`플레이어가 ${damage} 데미지를 입혔습니다! 적 HP: ${enemyHP}`);

    if (enemyHP <= 0) {
      battleText.setText('적을 쓰러뜨렸습니다! 전투 승리!');
      endBattle(scene);
    } else {
      turn = 'enemy';
      setTimeout(() => enemyAttack(scene), 1000);
    }
  }

  function enemyAttack(scene) {
    if (turn !== 'enemy') return;
    const damage = Phaser.Math.Between(5, 15);
    playerHP -= damage;
    battleText.setText(`적이 ${damage} 데미지를 입혔습니다! 플레이어 HP: ${playerHP}`);

    if (playerHP <= 0) {
      battleText.setText('플레이어가 쓰러졌습니다... 게임 오버!');
      endBattle(scene);
    } else {
      turn = 'player';
      battleText.setText('당신의 턴입니다.');
    }
  }

  function endBattle(scene) {
    inBattle = false;
    playerHP = 100;
    enemyHP = 50;

    // 전투 UI 버튼 제거
    scene.skillButtons.forEach(btn => btn.destroy());
    scene.skillButtons = [];

    battleText.setText('');
  }
  <script>
  let lastContent = null;
  async function checkUpdate() {
    try {
      const res = await fetch(window.location.href, {cache: "no-store"});
      const text = await res.text();
      if (lastContent && lastContent !== text) {
        console.log("새 버전 발견! 새로고침합니다.");
        location.reload();
      }
      lastContent = text;
    } catch(e) {
      console.error("업데이트 확인 실패", e);
    }
  }
  setInterval(checkUpdate, 5000);  // 5초마다 체크
  checkUpdate();
</script>
</body>
</html>
